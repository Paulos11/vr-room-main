// src/app/api/admin/tickets/quick-generate/route.ts - Quick ticket generation with registration
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'

const CustomerSchema = z.object({
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  email: z.string().email().optional().or(z.literal('')),
  phone: z.string().min(8),
  isEmsClient: z.boolean()
})

const TicketSchema = z.object({
  ticketTypeId: z.string(),
  quantity: z.number().min(1).max(10)
})

const QuickGenerateSchema = z.object({
  customer: CustomerSchema,
  tickets: z.array(TicketSchema),
  adminUser: z.string().optional()
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { customer, tickets, adminUser } = QuickGenerateSchema.parse(body)

    // Check if email already exists (if provided)
    if (customer.email && customer.email.trim()) {
      const existingRegistration = await prisma.registration.findUnique({
        where: { email: customer.email }
      })

      if (existingRegistration) {
        return NextResponse.json(
          { success: false, message: 'Email already registered. Use existing customer tab instead.' },
          { status: 400 }
        )
      }
    }

    // Verify ticket types and stock
    const ticketTypeIds = tickets.map(t => t.ticketTypeId)
    const ticketTypes = await prisma.ticketType.findMany({
      where: { 
        id: { in: ticketTypeIds },
        isActive: true
      }
    })

    if (ticketTypes.length !== ticketTypeIds.length) {
      return NextResponse.json(
        { success: false, message: 'One or more ticket types not found or inactive' },
        { status: 400 }
      )
    }

    // Validate stock availability
    for (const ticket of tickets) {
      const ticketType = ticketTypes.find(tt => tt.id === ticket.ticketTypeId)
      if (!ticketType) continue
      
      if (ticketType.availableStock < ticket.quantity) {
        return NextResponse.json(
          { success: false, message: `Insufficient stock for ${ticketType.name}. Available: ${ticketType.availableStock}` },
          { status: 400 }
        )
      }
    }

    // Create registration and tickets in transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create registration
      const registration = await tx.registration.create({
        data: {
          firstName: customer.firstName,
          lastName: customer.lastName,
          email: customer.email || `temp_${Date.now()}@quickticket.local`,
          phone: customer.phone,
          idCardNumber: '', // Not required for quick tickets
          isEmsClient: customer.isEmsClient,
          customerName: customer.isEmsClient ? `${customer.firstName} ${customer.lastName}` : null,
          originalAmount: 0,
          discountAmount: 0,
          finalAmount: 0,
          status: 'COMPLETED', // Auto-approve quick tickets
          adminNotes: `Quick ticket generated by ${adminUser || 'Admin'}`,
          verifiedAt: new Date(),
          verifiedBy: adminUser || 'System Admin'
        }
      })

      const generatedTickets = []
      
      for (const ticketRequest of tickets) {
        const ticketType = ticketTypes.find(tt => tt.id === ticketRequest.ticketTypeId)!
        
        for (let i = 0; i < ticketRequest.quantity; i++) {
          const ticketNumber = `TKT-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`
          const qrCode = `EMS-${registration.id}-${ticketNumber}`

          const ticket = await tx.ticket.create({
            data: {
              registrationId: registration.id,
              ticketTypeId: ticketRequest.ticketTypeId,
              ticketNumber,
              qrCode,
              purchasePrice: customer.isEmsClient ? 0 : ticketType.priceInCents,
              eventDate: new Date('2025-06-26'), // Event dates: 26 June - 06 July
              venue: 'Malta Fairs and Conventions Centre',
              boothLocation: 'EMS Booth - MFCC',
              status: 'GENERATED'
            }
          })

          generatedTickets.push(ticket)
        }

        // Update ticket type stock
        await tx.ticketType.update({
          where: { id: ticketRequest.ticketTypeId },
          data: {
            availableStock: { decrement: ticketRequest.quantity },
            soldStock: { increment: ticketRequest.quantity }
          }
        })
      }

      return { registration, tickets: generatedTickets }
    })

    // Log ticket generation
    if (customer.email && customer.email.trim()) {
      await prisma.emailLog.create({
        data: {
          registrationId: result.registration.id,
          emailType: 'TICKET_DELIVERY',
          subject: `${result.tickets.length} Quick Ticket(s) Generated`,
          recipient: customer.email,
          status: 'SENT'
        }
      })
    }

    return NextResponse.json({
      success: true,
      message: `Successfully created registration and generated ${result.tickets.length} ticket(s)`,
      data: {
        registration: {
          id: result.registration.id,
          name: `${result.registration.firstName} ${result.registration.lastName}`,
          email: result.registration.email,
          phone: result.registration.phone,
          isEmsClient: result.registration.isEmsClient
        },
        tickets: result.tickets.map(t => ({
          id: t.id,
          ticketNumber: t.ticketNumber,
          status: t.status
        }))
      }
    })

  } catch (error: any) {
    console.error('Error in quick ticket generation:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, message: 'Invalid data provided', errors: error.errors },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { success: false, message: 'Failed to generate quick tickets', error: error.message },
      { status: 500 }
    )
  }
}