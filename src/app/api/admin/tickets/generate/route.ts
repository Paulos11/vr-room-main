// src/app/api/admin/tickets/generate/route.ts - Enhanced ticket generation
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'

const TicketSchema = z.object({
  ticketTypeId: z.string(),
  quantity: z.number().min(1).max(10)
})

const GenerateTicketsSchema = z.object({
  registrationId: z.string(),
  tickets: z.array(TicketSchema),
  adminUser: z.string().optional()
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { registrationId, tickets, adminUser } = GenerateTicketsSchema.parse(body)

    // Verify registration exists
    const registration = await prisma.registration.findUnique({
      where: { id: registrationId }
    })

    if (!registration) {
      return NextResponse.json(
        { success: false, message: 'Registration not found' },
        { status: 404 }
      )
    }

    // Verify ticket types and stock
    const ticketTypeIds = tickets.map(t => t.ticketTypeId)
    const ticketTypes = await prisma.ticketType.findMany({
      where: { 
        id: { in: ticketTypeIds },
        isActive: true
      }
    })

    if (ticketTypes.length !== ticketTypeIds.length) {
      return NextResponse.json(
        { success: false, message: 'One or more ticket types not found or inactive' },
        { status: 400 }
      )
    }

    // Validate stock availability
    for (const ticket of tickets) {
      const ticketType = ticketTypes.find(tt => tt.id === ticket.ticketTypeId)
      if (!ticketType) continue
      
      if (ticketType.availableStock < ticket.quantity) {
        return NextResponse.json(
          { success: false, message: `Insufficient stock for ${ticketType.name}. Available: ${ticketType.availableStock}` },
          { status: 400 }
        )
      }
    }

    // Generate tickets in transaction
    const result = await prisma.$transaction(async (tx) => {
      const generatedTickets = []
      
      for (const ticketRequest of tickets) {
        const ticketType = ticketTypes.find(tt => tt.id === ticketRequest.ticketTypeId)!
        
        for (let i = 0; i < ticketRequest.quantity; i++) {
          const ticketNumber = `TKT-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`
          const qrCode = `EMS-${registrationId}-${ticketNumber}`

          const ticket = await tx.ticket.create({
            data: {
              registrationId,
              ticketTypeId: ticketRequest.ticketTypeId,
              ticketNumber,
              qrCode,
              purchasePrice: registration.isEmsClient ? 0 : ticketType.priceInCents,
              eventDate: new Date('2025-06-26'), // Event dates: 26 June - 06 July
              venue: 'Malta Fairs and Conventions Centre',
              boothLocation: 'EMS Booth - MFCC',
              status: 'GENERATED'
            }
          })

          generatedTickets.push(ticket)
        }

        // Update ticket type stock
        await tx.ticketType.update({
          where: { id: ticketRequest.ticketTypeId },
          data: {
            availableStock: { decrement: ticketRequest.quantity },
            soldStock: { increment: ticketRequest.quantity }
          }
        })
      }

      return generatedTickets
    })

    // Log ticket generation
    await prisma.emailLog.create({
      data: {
        registrationId,
        emailType: 'TICKET_DELIVERY',
        subject: `${result.length} Ticket(s) Generated by Admin`,
        recipient: registration.email,
        status: 'SENT'
      }
    })

    return NextResponse.json({
      success: true,
      message: `Successfully generated ${result.length} ticket(s)`,
      data: {
        tickets: result.map(t => ({
          id: t.id,
          ticketNumber: t.ticketNumber,
          status: t.status
        })),
        registration: {
          id: registration.id,
          name: `${registration.firstName} ${registration.lastName}`,
          email: registration.email
        }
      }
    })

  } catch (error: any) {
    console.error('Error generating tickets:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, message: 'Invalid data provided', errors: error.errors },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { success: false, message: 'Failed to generate tickets', error: error.message },
      { status: 500 }
    )
  }
}